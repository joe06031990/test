// Defines the start of a declarative Jenkins pipeline.
pipeline {
    // Specifies that the pipeline can run on any available Jenkins agent.
    agent any

    // Sets up an automatic schedule for the pipeline to run.
    triggers {
        // 'H/2 * * * *' means the job will run approximately every hour.
        cron('H/2 * * * *')
    }

    // Defines environment variables that will be available throughout the pipeline.
    environment {
        // Securely loads the Grafana API key from Jenkins credentials.
        GRAFANA_API_KEY = credentials('GRAFANA_API_KEY')
        // The URL of your Grafana instance.
        GRAFANA_URL = "https://jstest2025.grafana.net"
        // The name of the root directory where backups will be stored in the Git repository.
        GRAFANA_BACKUP_DIR = "playground_nonprd"
    }

    // Contains all the main work stages of the pipeline.
    stages {
        // The first stage: responsible for checking out code from your Git repository.
        stage('Checkout Git Repository') {
            steps {
                // The 'checkout' step clones or updates the specified Git repository and branch.
                checkout([$class: 'GitSCM', branches: [[name: '*/master']],
                          userRemoteConfigs: [[credentialsId: 'github-creds1', url: 'https://github.com/joe06031990/test']]])
            }
        }

        // THIS STAGE WILL NOW ONLY RUN ON THE 'master' BRANCH.
        stage('Run Grafana Dashboard Backup') {
            when {
                branch 'master'
            }
            steps {
                // A 'script' block allows for more complex Groovy code and logic.
                script {
                    // A multiline string variable in Groovy that holds the entire bash script.
                    def grafanaBackupScriptContent = '''#!/bin/bash
                            # 'set -e' ensures the script will exit immediately if a command fails.
                            set -e
                            # 'set -x' prints each command to the log before it is executed, useful for debugging.
                            set -x

                            CURL_CMD="/usr/bin/curl"
                            JQ_CMD="/usr/bin/jq"
                            
                            # Define the single root folder you want to back up.
                            PLAYGROUND_FOLDER_TITLE="playground"

                            # Sanity checks to ensure required tools and variables are present.
                            if [ ! -f "${CURL_CMD}" ]; then
                                echo "Error: 'curl' not found at ${CURL_CMD}. Please install it."
                                exit 1
                            fi
                            if [ ! -f "${JQ_CMD}" ]; then
                                echo "Error: 'jq' not found at ${JQ_CMD}. Please install it."
                                exit 1
                            fi
                            if [ -z "${GRAFANA_URL}" ] || [ -z "${GRAFANA_API_KEY}" ] || [ -z "${GRAFANA_BACKUP_DIR}" ]; then
                                echo "Missing required environment variables."
                                exit 1
                            fi
                            
                            echo "Starting targeted Grafana dashboard backup..."
                            echo "Target root folder: '${PLAYGROUND_FOLDER_TITLE}'"

                            # This command enables "mirror" mode by deleting the old backup directory.
                            rm -rf "${GRAFANA_BACKUP_DIR}"
                            mkdir -p "${GRAFANA_BACKUP_DIR}"

                            # Fetch all folders to find the ID of our target folder
                            ALL_FOLDERS=$(${CURL_CMD} -s -H "Authorization: Bearer ${GRAFANA_API_KEY}" "${GRAFANA_URL}/api/folders")
                            
                            # Use jq to extract the integer ID of the target folder
                            TARGET_FOLDER_ID=$(echo "${ALL_FOLDERS}" | ${JQ_CMD} -r --arg title "${PLAYGROUND_FOLDER_TITLE}" '.[] | select(.title==$title) | .id')

                            if [ -z "${TARGET_FOLDER_ID}" ]; then
                                echo "Error: Could not find a Grafana folder named '${PLAYGROUND_FOLDER_TITLE}'. Please ensure it exists."
                                exit 1
                            fi
                            echo "Found target folder '${PLAYGROUND_FOLDER_TITLE}' with ID: ${TARGET_FOLDER_ID}"

                            # Fetch a list of dashboards ONLY from the target folder and its subfolders.
                            ALL_DASHBOARDS_META=$(${CURL_CMD} -s -H "Authorization: Bearer ${GRAFANA_API_KEY}" "${GRAFANA_URL}/api/search?type=dash-db&folderIds=${TARGET_FOLDER_ID}")

                            # A function to clean up dashboard titles to make them safe for use as filenames.
                            sanitize_filename() {
                                echo "$1" | sed 's/[^a-zA-Z0-9._-]/_/g' | sed 's/__*/_/g' | sed 's/^_//;s/_$//'
                            }

                            # The folder reconstruction logic remains important for subfolders.
                            # We still build the full map to correctly place subfolder dashboards.
                            declare -A FOLDER_PATH_MAP
                            declare -A PARENT_LOOKUP
                            echo "${ALL_FOLDERS}" | ${JQ_CMD} -c '.[]' | while read -r folder; do
                                PARENT_LOOKUP[$(echo "${folder}" | ${JQ_CMD} -r '.uid')]=$(echo "${folder}" | ${JQ_CMD} -r '.title')
                            done

                            # Recursive function to build the full path for a folder
                            build_path() {
                                local uid=$1
                                local title=$(echo "${ALL_FOLDERS}" | ${JQ_CMD} -r --arg uid "$uid" '.[] | select(.uid==$uid) | .title')
                                local parent_uid=$(echo "${ALL_FOLDERS}" | ${JQ_CMD} -r --arg uid "$uid" '.[] | select(.uid==$uid) | .parentUid // empty')
                                
                                if [ -n "$parent_uid" ] && [ -n "${PARENT_LOOKUP[$parent_uid]}" ]; then
                                    local parent_path=$(build_path "$parent_uid")
                                    echo "${parent_path}/$(sanitize_filename "${title}")"
                                else
                                    # For the root "playground" folder, we want an empty base path inside the backup dir
                                    if [ "${title}" == "${PLAYGROUND_FOLDER_TITLE}" ]; then
                                        echo ""
                                    else
                                        echo "$(sanitize_filename "${title}")"
                                    fi
                                fi
                            }

                            echo "${ALL_FOLDERS}" | ${JQ_CMD} -c '.[]' | while read -r folder; do
                                FOLDER_UID=$(echo "$folder" | ${JQ_CMD} -r '.uid')
                                FOLDER_PATH_MAP[$FOLDER_UID]=$(build_path "$FOLDER_UID")
                            done

                            # Process the pre-filtered list of dashboards
                            echo "${ALL_DASHBOARDS_META}" | ${JQ_CMD} -c '.[]' | while read -r DASHBOARD_META_INFO; do
                                DASHBOARD_UID=$(echo "${DASHBOARD_META_INFO}" | ${JQ_CMD} -r '.uid')
                                DASHBOARD_TITLE=$(echo "${DASHBOARD_META_INFO}" | ${JQ_CMD} -r '.title')
                                FOLDER_UID=$(echo "${DASHBOARD_META_INFO}" | ${JQ_CMD} -r '.folderUid')

                                RELATIVE_PATH="${FOLDER_PATH_MAP[$FOLDER_UID]}"
                                
                                # Create the full path for saving the file
                                CURRENT_SAVE_DIR="${GRAFANA_BACKUP_DIR}"
                                if [ -n "${RELATIVE_PATH}" ]; then
                                    CURRENT_SAVE_DIR="${GRAFANA_BACKUP_DIR}/${RELATIVE_PATH}"
                                fi
                                mkdir -p "${CURRENT_SAVE_DIR}"

                                SANITIZED_DASH_TITLE=$(sanitize_filename "${DASHBOARD_TITLE}")
                                filename="${SANITIZED_DASH_TITLE}.json"
                                filepath="${CURRENT_SAVE_DIR}/${filename}"

                                echo "Processing dashboard '${DASHBOARD_TITLE}' -> ${filepath}"
                                
                                DASHBOARD_DATA=$(${CURL_CMD} -s -H "Authorization: Bearer ${GRAFANA_API_KEY}" "${GRAFANA_URL}/api/dashboards/uid/${DASHBOARD_UID}")
                                
                                if [ -n "${DASHBOARD_DATA}" ] && [ "$(${JQ_CMD} -r '.dashboard.title' <<< "${DASHBOARD_DATA}")" != "null" ]; then
                                    echo "${DASHBOARD_DATA}" | ${JQ_CMD} -r '.dashboard' > "${filepath}"
                                    echo " Saved: ${filepath}"
                                fi
                            done

                            echo "Backup of '${PLAYGROUND_FOLDER_TITLE}' folder and its subfolders is complete!"
                    '''

                    writeFile(file: 'run_grafana_backup.sh', text: grafanaBackupScriptContent)
                    sh 'chmod +x run_grafana_backup.sh'
                    sh 'bash ./run_grafana_backup.sh'
                }
            }
        }

        // THIS STAGE WILL NOW ONLY RUN ON THE 'master' BRANCH.
        stage('Commit and Push Changes to Git') {
            when {
                branch 'master'
            }
            steps {
                script {
                    sh "git config user.email 'jenkins@test.com'"
                    sh "git config user.name 'Jenkins Automated Backup'"
                    // Use 'git add --all' to ensure deleted files are staged for commit.
                    sh "git add --all ${env.GRAFANA_BACKUP_DIR}"

                    // Checks if there are any actual changes to commit.
                    def changes = sh(returnStatus: true, script: "git diff-index --quiet HEAD -- ${env.GRAFANA_BACKUP_DIR}")
                    
                    if (changes != 0) {
                        // This quoting allows the shell to correctly execute the 'date' command.
                        sh 'git commit -m "Grafana Dashboards Backup - $(date +%Y-%m-%d_%H-%M-%S)"'
                        
                        withCredentials([string(credentialsId: 'github-creds1', variable: 'GIT_PAT')]) {
                            sh '''
                                git remote set-url origin https://github.com/joe06031990/test
                                git config credential.helper store
                                echo "https://${GIT_PAT}:@github.com" > ~/.git-credentials
                                git push origin HEAD:master
                            '''
                        }
                    } else {
                        echo "No changes detected."
                    }
                }
            }
        }
    }

    // The 'post' section defines actions that run at the end of the pipeline.
    post {
        // 'always' means this action will run regardless of whether the pipeline succeeded or failed.
        always {
            // 'cleanWs' deletes all files from the workspace, ensuring a clean start for the next run.
            cleanWs()
        }
    }
}
